<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Blackjack Game</title>
<link rel="stylesheet" href="styles/style.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bungee+Tint&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">

<script>
// global variables
const suits = ["spades", "hearts", "diamonds", "clubs"];
const ranks = ["A",2,3,4,5,6,7,8,9,10,"J","Q","K"];
var deck = []; 
var dealerHand = [];
var playerHand = [];
var gameOver = false;

// Validate username
function validateUserName(username) {
    return new Promise(function(resolve, reject) {
        if(!username.trim()) {
            reject("User name cannot be blank.");
            return;
        }
        var regex = /^[a-zA-Z]+$/;
        if(!regex.test(username)) {
            reject("User name can only contain alpha characters.");
            return;
        }
        resolve(username);
    });
}

// Create full deck
function createDeck() {
    deck = [];
    for (let suit = 0; suit < suits.length; suit++) {
        for (let rank = 0; rank < ranks.length; rank++) {
            deck.push(new Card(suit, rank));
        }
    }
}

// Helper: get next undealt card
function getNextUndealtCard() {
    for (var i = 0; i < deck.length; i++) {
        if (!deck[i].dealt) {
            deck[i].dealt = true;
            return deck[i];
        }
    }
    return null;
}

// Card value helpers
function cardValue(card) {
    if (card.rank === "A") return 11;
    if (card.rank === "J" || card.rank === "Q" || card.rank === "K") return 10;
    return Number(card.rank);
}

function handValue(hand) {
    var total = 0;
    var aces = 0;
    for (var i = 0; i < hand.length; i++) {
        var c = hand[i];
        var v = cardValue(c);
        total += v;
        if (c.rank === "A") aces++;
    }
    // reduce aces from 11 to 1 as needed
    while (total > 21 && aces > 0) {
        total -= 10;
        aces--;
    }
    return total;
}

function updateHandsDisplay() {
    var dealerHTML = "";
    for (var i = 0; i < dealerHand.length; i++) {
        dealerHTML += dealerHand[i].show();
    }
    document.getElementById("dealerCards").innerHTML = dealerHTML;

    var playerHTML = "";
    for (var i = 0; i < playerHand.length; i++) {
        playerHTML += playerHand[i].show();
    }
    document.getElementById("playerCards").innerHTML = playerHTML;
}

function enableButtons(enable) {
    document.getElementById('hitButton').disabled = !enable;
    document.getElementById('standButton').disabled = !enable;
}

function endGame(message, resultType) {
    gameOver = true;
    enableButtons(false);
    var el = document.getElementById('resultMessage');
    if (!el) return;

    // Clear previous classes
    el.classList.remove('result-win','result-lose','result-push','shake');

    // Compose dramatic message + emoji
    var displayText = message;
    if (resultType === 'win') {
        displayText = 'ðŸŽ‰ ' + message + ' ðŸŽ‰';
        el.classList.add('result-win');
    } else if (resultType === 'lose') {
        displayText = 'ðŸ’¥ ' + message + ' ðŸ’¥';
        el.classList.add('result-lose','shake');
    } else {
        el.classList.add('result-push');
    }

    el.textContent = displayText;

    // Show Play Again button so user can restart without returning to form
    var pa = document.getElementById('playAgainButton');
    if (pa) pa.style.display = 'inline-block';

    // Launch confetti on win
    if (resultType === 'win') {
        launchConfetti();
    }
}

// Card constructor
function Card(suit, rank) {
    this.suit = suits[suit];
    this.rank = ranks[rank];
    this.isVisible = true; // visibility on table
    this.dealt = false;    // used to track if drawn
    this.image = this.constructCardImage();
}

// Card prototype to use actual card images
Card.prototype.constructCardImage = function() {
    var rankStr = "";
    switch(this.rank) {
        case "A": rankStr = "ace"; break;
        case "J": rankStr = "jack"; break;
        case "Q": rankStr = "queen"; break;
        case "K": rankStr = "king"; break;
        default: rankStr = this.rank.toString(); break;
    }
    return "images/" + rankStr + "_of_" + this.suit + ".svg";
};

// Show card: face up or back image if hidden
Card.prototype.show = function() {
    if (this.isVisible) {
        return '<img src="' + this.image + '" height="87" width="100">';
    } else {
        return '<img src="images/back.png" height="87" width="60">';
    }
};

// Hide card
Card.prototype.hide = function() {
    this.isVisible = false;
};

// Shuffle deck using Fisher-Yates
function shuffleDeck(showAlert = true) {
    for (var i = deck.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = deck[i];
        deck[i] = deck[j];
        deck[j] = temp;
    }

    // Reset all cards
    for (var i = 0; i < deck.length; i++) {
        deck[i].isVisible = true;
        deck[i].dealt = false;
    }

    // Do not auto-deal here; let the caller decide when to deal.
    if (showAlert) {
        alert("Deck shuffled! Click Deal or Start Game to deal cards.");
    }
}

// Context-aware shuffle handler used by the UI button
function handleShuffleClick() {
    var gameAreaVisible = document.getElementById('gameArea').style.display !== 'none';

    if (!gameAreaVisible) {
        // Not in a game yet: prepare deck and inform user
        createDeck();
        shuffleDeck(true);
        // clear any previous messages
        var rm = document.getElementById('resultMessage'); if (rm) rm.textContent = '';
        return;
    }

    // If we're in the game area
    if (!gameOver) {
        // Mid-round: reshuffle and start a fresh round
        if (confirm('Shuffle now will restart the current round. Proceed?')) {
            createDeck();
            shuffleDeck(false);
            dealInitialCards();
            alert('Deck shuffled â€” round restarted.');
            document.getElementById('resultMessage').textContent = '';
        }
    } else {
        // Round finished: just start a new round
        createDeck();
        shuffleDeck(false);
        dealInitialCards();
        alert('Deck shuffled. New round dealt.');
        document.getElementById('resultMessage').textContent = '';
    }
}

// Deal 2 dealer (one face down) and 2 player
function dealInitialCards() {
    // Guard: ensure there are enough cards to deal
    if (!deck || deck.length < 4) {
        console.error("Not enough cards in the deck to deal initial hands.");
        return;
    }

    dealerHand = [];
    playerHand = [];
    gameOver = false;

    // Dealer first card face up
    var c = getNextUndealtCard();
    if (!c) return;
    c.isVisible = true;
    dealerHand.push(c);

    // Dealer second card face down
    c = getNextUndealtCard();
    if (!c) return;
    c.isVisible = false;
    dealerHand.push(c);

    // Player first 2 cards face up
    for (var i = 0; i < 2; i++) {
        c = getNextUndealtCard();
        if (!c) return;
        c.isVisible = true;
        playerHand.push(c);
    }

    updateHandsDisplay();
    document.getElementById('resultMessage').textContent = '';
    // Hide Play Again button while a round is active
    var pa = document.getElementById('playAgainButton');
    if (pa) pa.style.display = 'none';
    enableButtons(true);
}



// Start game
async function startGame() {
    var username = document.getElementById('userName').value.trim();
    try {
        var validUsername = await validateUserName(username);
        document.getElementById('userForm').style.display = 'none';
        document.getElementById('gameArea').style.display = 'block';
        document.getElementById('welcomeMessage').textContent = "Welcome " + validUsername + "!";
        // Hide the instructions block once the game starts
        var instr = document.getElementById('instructions');
        if (instr) instr.style.display = 'none';

        createDeck();
        shuffleDeck(false);  // shuffle silently during start
        dealInitialCards();  // deal initial cards
    } catch (error) {
        alert(error);
    }
}

// Stand: reveal dealer's hidden card
function stand() {
    if (gameOver) return;

    // Reveal dealer's hidden card
    if (dealerHand.length > 1) dealerHand[1].isVisible = true;
    updateHandsDisplay();

    // Dealer draws until 17 or higher
    var dealerTotal = handValue(dealerHand);
    while (dealerTotal < 17) {
        var next = getNextUndealtCard();
        if (!next) break;
        next.isVisible = true;
        dealerHand.push(next);
        dealerTotal = handValue(dealerHand);
        updateHandsDisplay();
    }

    var playerTotal = handValue(playerHand);
    dealerTotal = handValue(dealerHand);

    var result = '';
    if (dealerTotal > 21) {
        result = 'Dealer busts (' + dealerTotal + '). You win! (' + playerTotal + ')';
        endGame(result, 'win');
        return;
    } else if (dealerTotal > playerTotal) {
        result = 'Dealer wins with ' + dealerTotal + ' vs your ' + playerTotal + '.';
        endGame(result, 'lose');
        return;
    } else if (dealerTotal < playerTotal) {
        result = 'You win with ' + playerTotal + ' vs dealer ' + dealerTotal + '!';
        endGame(result, 'win');
        return;
    } else {
        result = 'Push: both have ' + playerTotal + '.';
        endGame(result, 'push');
        return;
    }

}

// Hit: draw next card for player
function hit() {
    if (gameOver) return;

    var nextCard = getNextUndealtCard();
    if (!nextCard) {
        alert("No more cards in the deck!");
        return;
    }
    nextCard.isVisible = true;
    playerHand.push(nextCard);
    updateHandsDisplay();

    var total = handValue(playerHand);
    if (total > 21) {
        endGame('You bust with ' + total + '. Dealer wins.', 'lose');
    } else if (total === 21) {
        // Auto-stand on 21
        stand();
    }
}

// Return to form
function returnToForm() {
    document.getElementById('userForm').style.display = 'block';
    document.getElementById('gameArea').style.display = 'none';
    // Show the instructions again when returning to the form
    var instr = document.getElementById('instructions');
    if (instr) instr.style.display = 'block';
}

// Play again: reset deck and deal a fresh round keeping same user
function playAgain() {
    // Clear messages and hide the button
    var pa = document.getElementById('playAgainButton');
    if (pa) pa.style.display = 'none';
    document.getElementById('resultMessage').textContent = '';

    // Create fresh deck and deal again
    createDeck();
    shuffleDeck(false);
    dealInitialCards();
}

// Initialize modern button styles and ripple interaction
function initButtons() {
    document.querySelectorAll('button').forEach(btn => {
        // apply unified button class
        btn.classList.add('btn');

        // add ripple effect on click
        btn.addEventListener('click', function(e) {
            const rect = this.getBoundingClientRect();
            const ripple = document.createElement('span');
            ripple.className = 'ripple';
            const size = Math.max(rect.width, rect.height);
            ripple.style.width = ripple.style.height = size + 'px';
            ripple.style.left = (e.clientX - rect.left - size/2) + 'px';
            ripple.style.top = (e.clientY - rect.top - size/2) + 'px';
            this.appendChild(ripple);
            setTimeout(() => { try { ripple.remove(); } catch(e){} }, 650);
        });
    });
}

window.addEventListener('load', initButtons);

// Lightweight confetti animation (canvas-based)
function launchConfetti() {
    const count = 80;
    const colors = ['#fde68a','#fca5a5','#bfdbfe','#bbf7d0','#fbcfe8','#c7d2fe'];
    const canvas = document.createElement('canvas');
    canvas.className = 'confetti-canvas';
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    document.body.appendChild(canvas);
    const ctx = canvas.getContext('2d');

    let particles = [];
    for (let i = 0; i < count; i++) {
        particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * -canvas.height * 0.5,
            vx: (Math.random() - 0.5) * 6,
            vy: Math.random() * 4 + 2,
            size: Math.random() * 8 + 6,
            color: colors[Math.floor(Math.random() * colors.length)],
            rot: Math.random() * 360,
            dop: Math.random() * 0.03 + 0.015
        });
    }

    const start = performance.now();
    function render(now) {
        const t = (now - start) / 1000;
        ctx.clearRect(0,0,canvas.width,canvas.height);
        for (let p of particles) {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.12; // gravity
            p.rot += p.dop * 360;

            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rot * Math.PI / 180);
            ctx.fillStyle = p.color;
            ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.6);
            ctx.restore();
        }
        // remove if all particles are off-screen or time exceeded
        if (t > 2.4) {
            document.body.removeChild(canvas);
        } else {
            requestAnimationFrame(render);
        }
    }
    requestAnimationFrame(render);
}

</script>
</head>
<body>
<div class="game-container">
    <h1>Blackjack Game</h1>
    <div id="instructions" class="instructions">
        <h2>How to Play</h2>
        <ul>
            <li><strong>Objective:</strong> Get a hand value as close to 21 as possible without going over.</li>
            <li><strong>Card values:</strong> 2â€“10 face value, J/Q/K = 10, Ace = 1 or 11 (automatically adjusted).</li>
            <li><strong>Start:</strong> Enter your name and press Enter or click Start â€” you and the dealer each get two cards (dealer shows one face down).</li>
            <li><strong>Your turn:</strong> Click <em>Hit</em> to draw a card or <em>Stand</em> to end your turn.</li>
            <li><strong>Dealer rules:</strong> Dealer reveals the hidden card and draws until their total is 17 or higher.</li>
            <li><strong>Winning:</strong> If you go over 21 you bust and lose. If dealer busts you win. Otherwise higher total wins; equal totals are a push (tie).</li>
            <li><strong>Controls:</strong> <em>Hit</em>, <em>Stand</em>, <em>Shuffle Deck</em> and, after a round ends, <em>Play Again</em>.</li>
            <li><strong>Tip:</strong> Use Enter to start quickly; buttons are keyboard accessible.</li>
        </ul>
    </div>
    <form name="userForm" id="userForm" style="display: block;" onsubmit="startGame(); return false;">
        Enter your name: <input type="text" id="userName" autocomplete="name" autofocus> 
        <button type="submit">Start Game</button>
    </form>
</div>

<div id="gameArea" style="display: none;">
    <h2 id="welcomeMessage"></h2>

    <div>
        <h3>Dealer's Cards:</h3>
        <div id="dealerCards" class="cards"></div>
    </div>

    <div>
        <h3>Your Cards:</h3>
        <div id="playerCards" class="cards"></div>
    </div>

    <div id="buttons">
        <button id="hitButton" onclick="hit()">Hit</button>
        <button id="standButton" onclick="stand()">Stand</button>
        <button id="shuffleButton" onclick="handleShuffleClick()">Shuffle Deck</button>
        <button id="playAgainButton" style="display:none; margin-left:8px;" onclick="playAgain()">Play Again</button>
    </div>

    <h3 id="resultMessage"></h3>

    <button onclick="returnToForm()">Return to Form</button>
</div>
</body>
</html>
